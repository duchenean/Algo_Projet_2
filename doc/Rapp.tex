\documentclass[12pt, a4paper, table]{article}
%\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{textcomp}
\usepackage{mathtools,amssymb,amsthm}
\usepackage[left = 2cm, top = 2cm, right = 2cm, bottom = 2.5 cm, headheight = 0pt]{geometry}
\usepackage{graphicx}
\usepackage{pgf, tikz}
	\usetikzlibrary{arrows,shapes,positioning}
\usepackage{centernot}
\usepackage{pgffor, ifthen}
\usepackage{lmodern}
\usepackage{colortbl}
\usepackage{array}
\usepackage{calc}
\usepackage{titlesec}
\usepackage{titletoc}
\usepackage{fancyhdr}
\usepackage{fancybox}
\usepackage{titling}
\usepackage{enumitem}
\usepackage{wrapfig}
\usepackage{caption}
\usepackage{tocloft}
\usepackage{epigraph}
\usepackage{lipsum}
\usepackage{ulem}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\definecolor{light-gray}{gray}{0.95}
\setcounter{tocdepth}{0}

\titleformat{\section}
  {\normalfont\sffamily\Large\bfseries}
  {\thesection.}{0.5em}{}

\titleformat{\subsection}
  {\normalfont\sffamily\large\bfseries}
  {\thesubsection}{0.5em}{}
\titleformat{\subsubsection}
  {\normalfont\sffamily\normalsize\bfseries}
  {}{0.5em}{}


\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}


\lstset{language=Java,
 basicstyle=\footnotesize\tt,
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  moredelim=[il][\textcolor{pgrey}]{},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%},
    numbers=left,
    numberstyle=\color{pgrey}, % the style that is used for the line-numbers
  rulecolor=\color{black}
}

\pagestyle{fancy}

\setlength{\headheight}{15pt} 

\renewcommand{\headrulewidth}{1pt}
\fancyhead[C]{} 
\fancyhead[L]{\textsf{Groupe 14 \\ Antoine Duchêne - Justin Michaux}}
\fancyhead[R]{\textsf{LSINF1103 \\ Introduction à l'algorithmique}}

\renewcommand{\footrulewidth}{1pt}
\fancyfoot[C]{}
\fancyfoot[R]{\textbf{\textsf{\thepage}}}
\fancyfoot[L]{\textbf{\textsf{\today}}}

\begin{document}


\begin{Large} \begin{center}
\noindent \rule{15cm}{.9pt} 
\vspace{-0.33cm}
	\textsf{Mini-projet 2 -  Conception d’algorithme : Troycount}\\
	\rule{15cm}{.9pt} 
\end{center} \end{Large} 

\section{Explication de l'algorithme}
\begin{center}
\vspace{1cm}
	\includegraphics[width = 8.5cm]{sch}
\end{center}

\newpage

\fontfamily{phv}\selectfont
\section{Choix d'implémentation}
Afin d'implémenter l'arbre syntaxique abstrait, nous avons utilisé une structure chainée. Ce type d'implémentation a été préféré à un tableau dynamique car la complexité spatial avec un tableau est de $\mathbf{\Theta (2^{n})}$ alors qu'avec une structure chainée la complexité spacial est de $\mathbf{\Theta (n)}$.
\medskip

De plus, une structure chainée était un choix obligatoire vu la contrainte d'utiliser des méthodes récursives.
\vspace{-6pt}
\section{Complexité des différentes méthodes}
\noindent Soit n, le nombre d'opérations et de nombres : n représente donc la taille du problème à résoudre.
\vspace{-6pt}
\subsection{TreeBuilderIF.build()}
\noindent Complexité temporelle en $\mathbf{\Theta (n)}$ car :

\begin{enumerate}
	\item L'expression sera toujours parcourue entièrement 1 fois, à l'aide d'une boucle.
	\item La boucle principale ne contient que des opérations de complexité $\mathbf{\Theta (1)}$.
\end{enumerate}

\noindent On en déduit donc que le temps d'exécution augmentera de façon linéaire par rapport à la taille du problème.

\subsection{ExprIF.getReducedTree()}
\noindent Complexité temporelle en $\mathbf{\mathcal{O}(}\mathbf{log (n))}$ car :
\begin{enumerate}
	\item Complexité temporelle en $\mathbf{\mathcal{O}(h)}$, où h est la hauteur de l’arbre
	\item L'arbre est équilibré donc h $\in$ $\mathbf{\Theta(\mathbf{log}_{2} (n))}$
\end{enumerate}
Donc, 
\begin{itemize}
	\item Meilleur cas : $\mathbf{\Theta (1)}$ (on tombe sur la racine)
	\item Pire cas : $\mathbf{\Theta(}\mathbf{log (n))}$
	\item En général : $\mathbf{\mathcal{O}(}\mathbf{log (n))}$
\end{itemize}



\subsection{ExprIF.toString()}
\noindent Complexité temporelle en $\mathbf{\mathcal{O}(n)}$ car on passe, dans le pire des cas, 3x par chaque noeud de l'arbre (parcours d'Euler). On a donc une complexité en  $\mathbf{\mathcal{O}(3n)}$. On peut "simplifier" le 3 car il s'agit d'une constante. On obtient donc $\mathbf{\mathcal{O}(n)}$  

\begin{itemize}
	\item Meilleur cas : $\mathbf{\Theta (1)}$ (L'arbre est entièrement simplifié)
	\item Pire cas : $\mathbf{\Theta(n)}$
	\item En général : $\mathbf{\mathcal{O}(n)}$
\end{itemize}


\section{Difficultés rencontrées}
\begin{itemize}
	\item Quelques difficultés à implémenter une méthode récursive
	\item Choix d'implémentations
\end{itemize}



\newpage
\section*{Annexe}

\subsection*{Troycount.balance()}

\begin{lstlisting}[language=Java]
public Transaction[] balance() {
    Person[] persons = generateTabPersons();
    Arrays.sort(persons);

    int firstSplitIndex = 0;
    int secondSplitIndex = 0;

    for (int i = 0; persons[i].getBalance() >= 0; i++) {
    	secondSplitIndex++;
    	if (persons[i].getBalance() > 0) {
    		firstSplitIndex++;
        }
     }

    Person[] debtors = Arrays.copyOfRange(persons, 0, firstSplitIndex);
    Person[] creditors = Arrays.copyOfRange(persons, secondSplitIndex, persons.length);

    reverse(creditors);

    Stack<Transaction> transactions = new Stack<Transaction>();
    int i = 0, j = 0;

    while (i < debtors.length && j < creditors.length) {
        if (debtors[i].getBalance() <= -creditors[j].getBalance()){
            double transactionAmount = debtors[i].getBalance();
            Transaction t = new Transaction(debtors[i].getId(),
                                            creditors[j].getId(),
                                            transactionAmount);
            transactions.add(t);
            System.out.println(t);
            creditors[j].balanceAdd(transactionAmount);
            debtors[i].balanceSub(transactionAmount);
            i++;
        } else {
            double transactionAmount = -creditors[j].getBalance();
            Transaction t = new Transaction(debtors[i].getId(),
                                            creditors[j].getId(),
                                            transactionAmount);
            transactions.add(t);
            System.out.println(t);
            creditors[j].balanceAdd(transactionAmount);
            debtors[j].balanceSub(transactionAmount);
            j++;
		}
	}
    return transactions.toArray(new Transaction[transactions.size()]);
}
\end{lstlisting}
\newpage
\subsection*{Troycount.generateTabPerson()}
\begin{lstlisting}
public Person[] generateTabPersons() {
   Person[] persons = new Person[group_size];
   for (int i = 0; i < group_size; i++) {
      int personID = i + 1;
      persons[i] = new Person(personID);
   }
   for (Spending aSpending : spendings) {
      int debitedPerson = aSpending.get_paid_by()
      int[] chargedPerson = aSpending.get_paid_for();
      int chargedPersons = chargedPerson.length;
      double spendingAmount = aSpending.get_amount();
  
      for (int person : chargedPerson) { 
         double fixedCharge = aSpending.get_fixed_charges(person);
         spendingAmount -= fixedCharge;
      } 
      
      for (int person : chargedPerson) {
         persons[person - 1].balanceAdd(spendingAmount / chargedPersons);
      }
  
      persons[debitedPerson - 1].balanceSub(spendingAmount);
  }
  return persons;
}
\end{lstlisting}







\end{document}